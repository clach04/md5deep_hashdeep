Because I kept ignoring this list of TODO items, I have 
moved them all to the SourceForge Feature Request Tracker.
See https://sourceforge.net/tracker/?group_id=67079&atid=516781
for all current TODO items.

Here's what's left:
1 - Remove the file_name_annotation and instead remember the piecewise start and stop.
2 - Figure out why threading turns on piecewise problem.
3 - get hashlist matching working again

== 

Below is what we've done:
1  - Start with a new copy of the source
2  - fix the autoconf files.
6  - migrate to C++ (hashdeep is now hashdeep.cpp)
3 - add DFXML to the multihash program.
4 - add an output mode to the multihash program that exactly matches the output mode of the single hash md5deep, sha1deep, etc. This was done by using md5deep's output functions directly.
5 - add a mode to the multihash program that exactly matches the command-line options, and have that mode be the default when the command name changes. This was done by using md5deep's command line parser.
1 - Continue migration to C++ everywhere.
2 - change state to a C++ class.
3 - Remove the current_file stuff from state to create another C++ class.
4 - Have hash() function take the file being hashed and a place to put it. 
1 - Start replacing char * arrays with stl::string. Consider replacing TCHAR strings with vector<TCHAR>.  
2 - remove hashtable object for the STL red-black table.
1 - migrate all hash databases to a single class (hashlist.cpp)
2 - Fix -k so that it loads into that database
3 - Fix audit mode so that it reads from that database.
* - Loading hashes should return a string with the set of hashes that were added.
1 - Go through entire program looking for dead code.
5 - migrate to multi-threaded producer/consumer architecture with the file searching (dig) being the producer and hash() being the consumer.
6 - Add "-j" option to control how many threads; -j0 turns off threading.
* - error printing is mostly threadsafe

Below is what's planned:

2 - Add procesisng of all hash file formats to tests.
4 - a file pattern that specifies what files are hashed.

What's on hold 
================
Test cases:
 - An audit file with the MD5 hash changed to simulate a partial hash.
 - An audit file with the length changed to simulate a partial hash.
 - An audit file with with 1 million entries.

* Use this for comparing which hashes get added.

md5deep:
* Check adding an explicit hash with -a and -A
================================================================
Another test case:

C:\Users\Jesse Kornblum\Documents\tmp>hashdeep64 -bc md5 foo bar > known1

C:\Users\Jesse Kornblum\Documents\tmp>hashdeep64 -bc sha1 moo cow > known2

C:\Users\Jesse Kornblum\Documents\tmp>hashdeep64 -vvvbak known1 -k
known2 foo bar moo cow
hashdeep64: known2: Hashes not in same format as previously loaded
foo: Ok
bar: Ok
moo: Ok
cow: Ok
hashdeep64: Audit passed
         Files matched: 4
Files partially matched: 0
           Files moved: 0
       New files found: 0
 Known files not found: 0
================================================================
* Check triage mdoe
================================================================
Multithreading works, but not if you hash. 
problem is either:
 - the hashing
 - the printing of the hashes.